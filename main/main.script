game = require("game")

local SPEED = 5

local VECTOR_UP = vmath.vector3(0, 1, 0)
local function rotate(id, normal)
	if normal.y == -1 then
		go.set(id, "euler.z", 180)
	else
		go.set_rotation(vmath.quat_from_to(VECTOR_UP, normal), id)
	end
end

local PROJECTILE_SPEED = 200
local DOT_RAY = vmath.vector3(0, 500, 0)
local WORLD_GROUP = { hash("world") }
local PROP_TINT = hash("tint")
local PROP_ALPHA = hash("tint.w")
local PROP_POSITION = hash("position")
local MAX_TRAVEL_TIME = DOT_RAY.y / PROJECTILE_SPEED
local function start(self)
	timer.delay(1.5, true, function()
		local last_ray
		for degrees = 1,365,0.25 do
			local offset = vmath.rotate(vmath.quat_rotation_z(math.rad(degrees)), DOT_RAY)
			local end_pos = self.pos + offset

			local ray
			if degrees % 1 == 0 then
				ray = physics.raycast(self.pos, end_pos, WORLD_GROUP)
				last_ray = ray
			else
				ray = last_ray
			end

			local dot_id = factory.create(self.dot_factory, self.pos)
			local sprite_url = msg.url(nil, dot_id, "sprite")
			go.set(sprite_url, PROP_TINT, self.color)

			if ray then
				go.animate(dot_id, PROP_POSITION, go.PLAYBACK_ONCE_FORWARD, self.pos + offset * ray.fraction, go.EASING_LINEAR, vmath.length(self.pos - ray.position)/PROJECTILE_SPEED, 0, function()
					go.animate(sprite_url, PROP_ALPHA, go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_OUTSINE, 0.1, 0, function()
						if degrees % 1 > 0 then return go.delete(dot_id) end
						rotate(dot_id, ray.normal)

						local particle_url = msg.url(nil, dot_id, "splash")
						particlefx.play(particle_url, function(_, _, _, state)
							if state == particlefx.EMITTER_STATE_POSTSPAWN then
								go.delete(dot_id)
							end
						end)
						particlefx.set_constant(particle_url, "emitter", PROP_TINT, self.color)
					end)
				end)
			else
				go.animate(dot_id, PROP_POSITION, go.PLAYBACK_ONCE_FORWARD, end_pos, go.EASING_LINEAR, MAX_TRAVEL_TIME)
				go.animate(sprite_url, PROP_ALPHA, go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_OUTSINE, 0.2, MAX_TRAVEL_TIME - 0.2, function()
					go.delete(dot_id)
				end)
			end
		end
	end)
end

local function move_x(self, x)
	local new_pos = self.pos + vmath.vector3(x, 0, 0)

	local ray = physics.raycast(self.pos, new_pos, {hash("world")})
	if not ray then
		self.pos = new_pos
	else
		self.velocity.x = self.velocity.x * -0.5
	end
end

local function move_y(self, y)
	local new_pos = self.pos + vmath.vector3(0, y, 0)

	local ray = physics.raycast(self.pos, new_pos, {hash("world")})
	if not ray then
		self.pos = new_pos
	else
		self.velocity.y = self.velocity.y * -0.5
	end
end

local function move(self, offset)
	if vmath.length_sqr(offset) == 0 then return end

	if offset.x ~= 0 then
		move_x(self, offset.x)
	end
	if offset.y ~= 0 then
		move_y(self, offset.y)
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	MAP_X, MAP_Y, MAP_W, MAP_H = tilemap.get_bounds("/map#map")
	self.pos = vmath.vector3(480, 320, 1)
	self.input = vmath.vector3()
	self.velocity = vmath.vector3()
	self.color = vmath.vector4(0, 0.2, 0.8, 1)
	self.dot_factory = msg.url("#factory")

	go.set("go2#sprite", "tint", self.color * 1.5)
	particlefx.play("go2#trail")
	particlefx.set_constant("go2#trail", "emitter", "tint", self.color)

	start(self)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

local ACCELERATION = 500
function update(self, dt)
	if vmath.length_sqr(self.input) > 0 then
		self.velocity = self.velocity + vmath.normalize(self.input) * ACCELERATION * dt
	end
	self.velocity = self.velocity * 0.99
	move(self, self.velocity * dt)
	go.set_position(self.pos, "go2")
	self.input.x, self.input.y = 0, 0
end

function fixed_update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action_id == hash("up") then
		self.input.y = 1
	elseif action_id == hash("down") then
		self.input.y = -1
	elseif action_id == hash("left") then
		self.input.x = -1
	elseif action_id == hash("right") then
		self.input.x = 1
	end

	if action.pressed then
		if action_id == hash("p") then
			msg.post("@system:", "toggle_profile")
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
